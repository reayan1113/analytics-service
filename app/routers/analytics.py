"""Analytics API endpoints"""
import logging
from typing import Optional
from datetime import date, timedelta
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from app.database import get_order_db_session, get_analytics_db_session
from app.services.analytics_service import AnalyticsService
from app.schemas.analytics import (
    AnalyticsSummaryResponse,
    TopItemsResponse,
    HourlyBreakdownResponse,
    DailyForecastResponse,
    HourlyForecastResponse,
    DailySummary,
    TopItem,
    HourlyBreakdown,
    DailyForecast,
    HourlyForecast
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/admin/analytics", tags=["Analytics"])


@router.get("/summary", response_model=AnalyticsSummaryResponse)
async def get_analytics_summary(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    limit: int = Query(30, ge=1, le=365, description="Maximum number of records"),
    order_db: Session = Depends(get_order_db_session),
    analytics_db: Session = Depends(get_analytics_db_session)
):
    """
    Get daily analytics summary from cache
    
    Returns precomputed daily revenue, order count, and average order value
    """
    logger.info(f"Fetching analytics summary: start={start_date}, end={end_date}, limit={limit}")
    
    service = AnalyticsService(order_db, analytics_db)
    summaries = service.get_daily_summaries(
        start_date=start_date,
        end_date=end_date,
        limit=limit
    )
    
    daily_summaries = [
        DailySummary(
            date=s.date,
            total_revenue=s.total_revenue,
            order_count=s.order_count,
            average_order_value=s.average_order_value
        )
        for s in summaries
    ]
    
    return AnalyticsSummaryResponse(
        daily_summaries=daily_summaries,
        total_records=len(daily_summaries)
    )


@router.get("/top-items", response_model=TopItemsResponse)
async def get_top_items(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    limit: int = Query(10, ge=1, le=100, description="Number of top items"),
    order_db: Session = Depends(get_order_db_session),
    analytics_db: Session = Depends(get_analytics_db_session)
):
    """
    Get top selling items
    
    Computed from order data on demand (relatively lightweight query)
    """
    logger.info(f"Fetching top items: start={start_date}, end={end_date}, limit={limit}")
    
    service = AnalyticsService(order_db, analytics_db)
    top_items_data = service.get_top_items(
        start_date=start_date,
        end_date=end_date,
        limit=limit
    )
    
    top_items = [
        TopItem(
            item_id=item['item_id'],
            item_name=item['item_name'],
            total_quantity=item['total_quantity'],
            total_revenue=item['total_revenue']
        )
        for item in top_items_data
    ]
    
    return TopItemsResponse(
        top_items=top_items,
        total_items=len(top_items)
    )


@router.get("/hourly", response_model=HourlyBreakdownResponse)
async def get_hourly_breakdown(
    target_date: Optional[date] = Query(None, description="Target date (defaults to today)"),
    days_back: int = Query(7, ge=1, le=30, description="Number of days to include"),
    order_db: Session = Depends(get_order_db_session),
    analytics_db: Session = Depends(get_analytics_db_session)
):
    """
    Get hourly order breakdown from cache
    
    Returns precomputed hourly order counts
    """
    if not target_date:
        target_date = date.today()
    
    logger.info(f"Fetching hourly breakdown: date={target_date}, days_back={days_back}")
    
    service = AnalyticsService(order_db, analytics_db)
    hourly_data = service.get_hourly_breakdown(
        target_date=target_date,
        days_back=days_back
    )
    
    hourly_breakdown = [
        HourlyBreakdown(
            date=h.date,
            hour=h.hour,
            order_count=h.order_count
        )
        for h in hourly_data
    ]
    
    return HourlyBreakdownResponse(
        hourly_data=hourly_breakdown,
        total_records=len(hourly_breakdown)
    )


@router.get("/forecast/daily", response_model=DailyForecastResponse)
async def get_daily_forecast(
    limit: int = Query(7, ge=1, le=30, description="Number of forecast days"),
    order_db: Session = Depends(get_order_db_session),
    analytics_db: Session = Depends(get_analytics_db_session)
):
    """
    Get daily revenue forecast
    
    Returns precomputed forecasts generated by midnight batch process
    """
    logger.info(f"Fetching daily forecast: limit={limit}")
    
    service = AnalyticsService(order_db, analytics_db)
    forecasts_data = service.get_daily_forecasts(
        forecast_type='daily_revenue',
        limit=limit
    )
    
    forecasts = [
        DailyForecast(
            forecast_date=f.forecast_date,
            forecast_value=f.forecast_value,
            forecast_type=f.forecast_type
        )
        for f in forecasts_data
    ]
    
    return DailyForecastResponse(
        forecasts=forecasts,
        total_forecasts=len(forecasts)
    )


@router.get("/forecast/hourly", response_model=HourlyForecastResponse)
async def get_hourly_forecast(
    forecast_date: Optional[date] = Query(None, description="Forecast date (defaults to tomorrow)"),
    order_db: Session = Depends(get_order_db_session),
    analytics_db: Session = Depends(get_analytics_db_session)
):
    """
    Get hourly order count forecast
    
    Returns precomputed hourly forecasts for specified date
    """
    if not forecast_date:
        forecast_date = date.today() + timedelta(days=1)
    
    logger.info(f"Fetching hourly forecast for: {forecast_date}")
    
    service = AnalyticsService(order_db, analytics_db)
    forecasts_data = service.get_hourly_forecasts(
        forecast_date=forecast_date
    )
    
    # Parse hour from forecast_type (format: 'hourly_HH')
    forecasts = []
    for f in forecasts_data:
        try:
            hour = int(f.forecast_type.split('_')[1])
            forecasts.append(
                HourlyForecast(
                    hour=hour,
                    forecast_value=f.forecast_value
                )
            )
        except (IndexError, ValueError):
            logger.warning(f"Invalid forecast type format: {f.forecast_type}")
            continue
    
    # Sort by hour
    forecasts.sort(key=lambda x: x.hour)
    
    return HourlyForecastResponse(
        forecasts=forecasts,
        total_forecasts=len(forecasts)
    )
